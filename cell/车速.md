# 车速平滑更新功能文档

## 概述

该功能旨在避免车速显示的抖动问题，特别是当车速变化较小时，平滑地更新车速显示值。该方案适用于嵌入式设备中的车速显示，确保车速显示的平稳性，减少不必要的跳动。

## 功能描述

代码通过比较目标车速与当前车速的差值，判断是否需要更新显示值。根据不同情况，采取不同的更新策略：

1. **车速小于等于 2 时，实时更新显示值**。
2. **当车速大于当前显示值时，逐步增加显示值**。
3. **当车速小于当前显示值时，只有当车速差值超过 2 时才更新显示值**。

## 主要函数

### `run()`

该函数根据目标车速和当前车速之间的差异，逐步更新显示值。更新的增量是通过 `acc.accumulated` 获取的。

#### 代码：

```c
static void run() {
  int inc = acc.accumulated;
  int target = acc.data;

  if (acc.current < target) {
    acc.current = (acc.current + inc > target) ? target : acc.current + inc;
  } else if (acc.current > target) {
    acc.current = (acc.current - inc < target) ? target : acc.current - inc;
  }
}

static bool should_udpate(int target, int current) {
  if (target <= 2)
    return true;
  else if (target > current)
    return true;
  else if ((target + 2) < current)
    return true;

  return false;
}

void speed_view_run() {
  acc.data = motor_model_get_speed();
  if (should_udpate(acc.data, acc.current))
    run();
}
```

### 可以进一步改进的地方:

1. **平滑更新的比例: 当前的实现每次增减车速都按照一个固定的增量 acc.accumulated 来更新车速，可能会造成显示更新的速率过快或过慢。你可以根据车速的变化幅度动态调整增量，或者让 acc.accumulated 在不同车速范围内有不同的表现，这样能进一步平滑显示。**
2. **更细粒度的控制: 如果需要更精细的控制，你可以增加一个 delta 参数来表示车速变化的比例，比如车速变化大于 10% 时就快速更新，10% 以下时平滑过渡。**
